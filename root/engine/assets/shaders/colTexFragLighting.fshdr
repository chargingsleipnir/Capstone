precision mediump float;

varying vec4 v_Position;
varying vec3 v_TransformedNormal;
varying vec3 v_Color;
varying vec2 v_TextureCoord;

uniform vec3 u_ColourTint;
uniform vec3 u_Diffuse_Color;
uniform float u_Diffuse_Intensity;
uniform vec3 u_Specular_Color;
uniform float u_Specular_Intensity;
//uniform float u_Specular_Hardness;
//uniform vec3 u_Mirror_Color;
//uniform float u_Mirror_Distance;
//uniform float u_Mirror_Reflectivity;
//uniform float u_Shading_Ambient;
//uniform float u_Shading_Emit;
//uniform float u_Shading_Translucency;
uniform float u_Alpha;
//uniform float u_Darkness;

uniform float u_Light_Ambient_Brightness;
uniform float u_Light_Directional_Brightness;
uniform vec3 u_Light_Directional_Direction;
uniform float u_Light_Point_Brightness;
uniform vec3 u_Light_Point_Position;

uniform sampler2D u_Sampler;

void main()
{
	vec3 lightWeighting;
	vec4 textureColor = texture2D(u_Sampler, vec2(v_TextureCoord.s, v_TextureCoord.t));

	// I should probably include a drop-off value, squared principle of light decay?
	if(u_Light_Ambient_Brightness == 0.0 && u_Light_Directional_Brightness == 0.0 && u_Light_Point_Brightness == 0.0)
        lightWeighting = vec3(1.0, 1.0, 1.0);
    else
    {
		float directional_Weighting = 0.0;
		float point_Weighting = 0.0;

		vec3 diffuseColorWeighting = u_Diffuse_Color * u_Diffuse_Intensity;
		vec3 specularColorWeighting = vec3(0.0, 0.0, 0.0);
		float specularBrightness = 0.0;

		vec3 ambientColor = diffuseColorWeighting * u_Light_Ambient_Brightness;
		vec3 directionalColor = vec3(0.0, 0.0, 0.0);
		vec3 pointColor = vec3(0.0, 0.0, 0.0);

		vec3 eyeDirection = normalize(-v_Position.xyz);
		vec3 reflectionDirection = vec3(0.0, 0.0, 0.0);
        vec3 normal = normalize(v_TransformedNormal);

		if(u_Light_Directional_Brightness > 0.0)
		{
            reflectionDirection = reflect(-u_Light_Directional_Direction, normal);
			specularBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), u_Specular_Intensity);
            specularColorWeighting = u_Specular_Color * specularBrightness;

			directional_Weighting = max(dot(normal, u_Light_Directional_Direction), 0.0) * u_Light_Directional_Brightness;

			directionalColor = (diffuseColorWeighting * directional_Weighting) +
								(specularColorWeighting * directional_Weighting);
		}
		if(u_Light_Point_Brightness > 0.0)
		{
			vec3 light_Point_Direction = normalize(u_Light_Point_Position - v_Position.xyz);
			reflectionDirection = reflect(-light_Point_Direction, normal);
			specularBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), u_Specular_Intensity);
            specularColorWeighting = u_Specular_Color * specularBrightness;

			point_Weighting = max(dot(normal, light_Point_Direction), 0.0) * u_Light_Point_Brightness;

			pointColor = (diffuseColorWeighting * point_Weighting) +
						  (specularColorWeighting * point_Weighting);
		}

		lightWeighting = ambientColor + directionalColor + pointColor;
	}

	/*
	if (textureColor.a == 0.0)
		textureColor = vec4(1.0, 1.0, 1.0, 1.0);
	gl_FragColor = textureColor * vec4(v_Color.rgb * v_LightWeighting, v_Color.a);
	*/

	/*
	if (textureColor.a == 0.0)
		textureColor.rgb = vec3(1.0, 1.0, 1.0);
	gl_FragColor = vec4(textureColor.rgb * v_Color * lightWeighting, max(textureColor.a, u_Alpha));
	*/

	if (textureColor.a == 0.0)
		textureColor.rgb = vec3(1.0, 1.0, 1.0);
	gl_FragColor = vec4((textureColor.rgb * v_Color * lightWeighting) + u_ColourTint, u_Alpha);

	/*
	if (textureColor.a == 0.0)
		gl_FragColor = vec4(v_Color.rgb * v_LightWeighting, v_Color.a);
	else
		gl_FragColor = textureColor;
	*/

	//gl_FragColor = mix(textureColor, v_Color, 0.5);
}