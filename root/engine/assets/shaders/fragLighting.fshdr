precision mediump float;

varying vec4 v_Position;
varying vec3 v_TransformedNormal;

uniform vec3 u_ColourTint;
uniform vec3 u_Diffuse_Color;
uniform vec3 u_Specular_Color;
uniform float u_Specular_Intensity;
//uniform float u_Specular_Hardness;
//uniform vec3 u_Mirror_Color;
//uniform float u_Mirror_Distance;
//uniform float u_Mirror_Reflectivity;
//uniform float u_Shading_Ambient;
//uniform float u_Shading_Emit;
//uniform float u_Shading_Translucency;
uniform float u_Alpha;
//uniform float u_Darkness;

uniform float u_Light_Ambient_Brightness;
uniform float u_Light_Directional_Brightness;
uniform vec3 u_Light_Directional_Direction;
uniform float u_Light_Point_Brightness;
uniform vec3 u_Light_Point_Position;

void main()
{
	vec3 lightWeighting;

	// I should probably include a drop-off value, squared principle of light decay?

	float directional_Weighting = 0.0;
	float point_Weighting = 0.0;

	vec3 specularColorWeighting = vec3(0.0, 0.0, 0.0);
	float specularBrightness = 0.0;

	vec3 ambientColor = u_Diffuse_Color * u_Light_Ambient_Brightness;
	vec3 directionalColor = vec3(0.0, 0.0, 0.0);
	vec3 pointColor = vec3(0.0, 0.0, 0.0);

	vec3 eyeDirection = normalize(-v_Position.xyz);
	vec3 reflectionDirection = vec3(0.0, 0.0, 0.0);
    vec3 normal = normalize(v_TransformedNormal);

	if(u_Light_Directional_Brightness > 0.0)
	{
        reflectionDirection = reflect(-u_Light_Directional_Direction, normal);
		specularBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), u_Specular_Intensity);
        specularColorWeighting = u_Specular_Color * specularBrightness;

		directional_Weighting = max(dot(normal, u_Light_Directional_Direction), 0.0) * u_Light_Directional_Brightness;

		directionalColor = (u_Diffuse_Color * directional_Weighting) +
							(specularColorWeighting * directional_Weighting);
	}
	if(u_Light_Point_Brightness > 0.0)
	{
		vec3 light_Point_Direction = normalize(u_Light_Point_Position - v_Position.xyz);
		reflectionDirection = reflect(-light_Point_Direction, normal);
		specularBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), u_Specular_Intensity);
        specularColorWeighting = u_Specular_Color * specularBrightness;

		point_Weighting = max(dot(normal, light_Point_Direction), 0.0) * u_Light_Point_Brightness;

		pointColor = (u_Diffuse_Color * point_Weighting) +
						(specularColorWeighting * point_Weighting);
	}

	lightWeighting = ambientColor + directionalColor + pointColor;

	gl_FragColor = vec4(lightWeighting + u_ColourTint, u_Alpha);
}